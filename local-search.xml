<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MongoDB之oplog</title>
    <link href="/2019/11/19/MongoDB%E4%B9%8Boplog/"/>
    <url>/2019/11/19/MongoDB%E4%B9%8Boplog/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>初识oplog</strong><br>在进行mongoDB与Es数据同步时，被告知只有开启MongoDB副本集才可以进行数据同步，副本集最重要的一点就是节点之间同步数据的以及MongoDB与Es同步数据，依靠的就是oplog。</p></blockquote><blockquote><p><strong>认识oplog</strong><br>oplog 是 MongoDB 主从复制层面的一个概念，通过 oplog 来实现复制集节点间数据同步，客户端将数据写入到 Primary，Primary 写入数据后会记录一条 oplog，Secondary 从 Primary（或其他 Secondary ）拉取 oplog 并重放，来确保复制集里每个节点存储相同的数据。<br>oplog 在 MongoDB 里是一个普通的 capped collection，对于存储引擎来说，oplog只是一部分普通的数据而已。——MongoDB中文社区</p></blockquote><blockquote><p><strong>Tips</strong></p></blockquote><ul><li>capped collection 为一个固定大小集合，oplog存在覆盖的情况，实际上这种情况也是允许的，也不能一直保存这些“操作日志”。所以设置oplog所在集合的大小是一件十分重要的事情，设置过小会导致数据备份丢失的危险；设置过大会浪费存储空。一般默认的是disk空间的5%（1G~50G）。可以通过–oplogSize参数来设置大小。</li><li>oplog中的同一条记录执行多次的结果和执行一次的结果是一样的。</li></ul><p>oplog是MongoDB与Es数据同步的基础，mongo-connrctor是利用oplog向Es中写入数据的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7部署MongoDB</title>
    <link href="/2019/11/19/Centos7%E9%83%A8%E7%BD%B2MongoDB/"/>
    <url>/2019/11/19/Centos7%E9%83%A8%E7%BD%B2MongoDB/</url>
    
    <content type="html"><![CDATA[<h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><blockquote><p><strong>下载源码包</strong><br><code>mkdir mongo &amp;&amp; cd mongo</code>新建一个文件夹用来存放源码文件<br>下载：<br>1、在Linux在终端执行<code>weget &#39;mongoDB下载地址&#39;</code><br>2、在本地下载完成后，使用FTP工具上传至Linux服务器<br>3、关注文末微信公众号，回复“MongoDB”获取网盘链接^^<br><code>tar zxvf 包文件.tar</code>解压文件。</p></blockquote><blockquote><p><strong>配置文件</strong><br>进入mongodb解压文件夹，编辑mongo.conf文件（如果没有自己创建也可以）</p></blockquote><pre><code class="hljs vala"><span class="hljs-comment">//编辑文件</span>vim mongo.conf<span class="hljs-comment">//写入如下文本</span><span class="hljs-meta">#port 端口号</span>port=<span class="hljs-number">27017</span><span class="hljs-meta">#dbpath 数据库存储文件目录</span>dbpath=/home/mongo/data<span class="hljs-meta">#logpath 日志路径</span>logpath=/home/mongo/logs/mongodb.log<span class="hljs-meta">#logappend 日志追加形式  false:重新启动覆盖文件</span>logappend=<span class="hljs-literal">true</span><span class="hljs-meta">#fork 后台启动</span>fork=<span class="hljs-literal">true</span><span class="hljs-meta">#开启副本集</span>replSet=[副本集名称]<span class="hljs-meta">#绑定ip</span>bind_ip=<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span></code></pre><blockquote><p><strong>启动</strong></p></blockquote><pre><code class="hljs awk">cd ./bin<span class="hljs-regexp">//</span>启动./mongo --config [配置文件地址]<span class="hljs-regexp">//</span>进入客户端./mongo --port <span class="hljs-number">27017</span><span class="hljs-regexp">//</span>显示如下内容 PRIMARY&gt;表示当前结点为主节点，在此节点的写操作和修改操作将会同步到副本节点MongoDB shell version v4.<span class="hljs-number">0.13</span>connecting to: mongodb:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">27017</span>/?gssapiServiceName=mongodbImplicit session: session &#123; <span class="hljs-string">&quot;id&quot;</span> : UUID(<span class="hljs-string">&quot;89d46323-09ab-47c1-a37a-95f20cd030bd&quot;</span>) &#125;MongoDB server version: <span class="hljs-number">4.0</span>.<span class="hljs-number">13</span>[副本集名称]:PRIMARY&gt;<span class="hljs-regexp">//</span>创建初始化配置文件，如果是单机安装，可以省略。[副本集名称]:PRIMARY&gt;config = &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;副本集名称&quot;</span>,<span class="hljs-string">&quot;members&quot;</span>:[  &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;host&quot;</span>:<span class="hljs-string">&quot;192.168.198.224:27017&quot;</span>&#125;,<span class="hljs-comment">#可以是单机的不同端口之间按进行集群</span>  &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;host&quot;</span>:<span class="hljs-string">&quot;192.168.198.225:27017&quot;</span>&#125;,  &#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;host&quot;</span>:<span class="hljs-string">&quot;192.168.198.226:27017&quot;</span>,arbiterOnly:true&#125;]&#125;<span class="hljs-regexp">//</span>执行初始化过程，没有配置文件可以省略参数config[副本集名称]:PRIMARY&gt;rs.initiate(config);<span class="hljs-regexp">//</span>查看集群状态[副本集名称]:PRIMARY&gt;rs.status();<span class="hljs-regexp">//</span>创建数据库use test<span class="hljs-regexp">//</span>插入数据,testdb为集合名称，可自动创建db.testdb.insert(&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;胡图图&quot;</span>&#125;);<span class="hljs-regexp">//</span>打开其他节点的客户端，此时其他节点的数据已经同步更新，因为mongodb默认是从主节点读写数据的，副本节点上不允许读，需要设置副本节点可以读。db.getMongo().setSlaveOk();<span class="hljs-comment">#</span><span class="hljs-regexp">//</span>正常读取db.testdb.find();</code></pre><p>打开mongoDB副本集是为了以后的mongoDB 与 ElasticSearch 进行数据同步做准备。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch-2</title>
    <link href="/2019/11/19/ElasticSearch-2/"/>
    <url>/2019/11/19/ElasticSearch-2/</url>
    
    <content type="html"><![CDATA[<h2 id="ElasticSearch是一个分布式文档型数据库"><a href="#ElasticSearch是一个分布式文档型数据库" class="headerlink" title="ElasticSearch是一个分布式文档型数据库"></a>ElasticSearch是一个分布式文档型数据库</h2><h3 id="Es是如何存储、检索数据的？"><a href="#Es是如何存储、检索数据的？" class="headerlink" title="Es是如何存储、检索数据的？"></a>Es是如何存储、检索数据的？</h3><p>在了解Es的存储机制，先要了解什么是集群(cluster)、节点(node)和分片(shard)。</p><blockquote><p><strong>集群</strong><br>当我们启动一个单独的Es节点时,就形成了一个集群，只不过在这个集群中只有一个节点（集群和分布式的区别在于集群是一个整体概念，即客户端对待集群适当做一个业务整体；分布式强点的则是“分”，整个业务被分成多个子业务，在不同的节点完成。）</p></blockquote><blockquote><p><strong>节点</strong><br>Es集群中的每一个节点就是一个Es实例，都可以单独完成Es的全部业务操作。它们具有相同的<code>cluster.name</code>，它们协同工作，分享数据和负载。</p></blockquote><blockquote><p><strong>分片</strong><br>分片是一个最小级别的“工作单元”，它保存了索引中所有数据的一部分，每个“分片”分为主分片和副本分片。同时每一个分片还是一个Lucene实例，其本身就是一个完整的搜索引擎。我们的文档被存贮在分片中，并且在分片中被索引，但是应用程序不会直接和分片进行交互，而是跟索引进行交互。这里的作引就可以被认为是一个或多个分片的“逻辑命名空间”。</p></blockquote><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>启动一个Es集群，该集群中有10个节点分布在不同的服务器上，每个节点中默认含有5个分片，每个分片有1个副本。副本分片和主分片在一个节点上的意义不大，所以在集群中，Master节点会自动调整每个节点中的分片数量和类型。当每个主分片都启动成功，且副分片也启动成功，此时的集群健康状态为<code>blue</code>；当主分pain启动成功，但是副分片没有全部启动成功，集群的健康状态为<code>yello</code>；当主节点没有完全启动成功，集群的健康状态为<code>red</code>。</p><blockquote><p><strong>存储过程</strong><br>1、客户端向集群中的<code>client_node</code>发送新建、索引和删除请求。<br>2、节点根据文档_<code>id</code>计算出文档属于的分片，假设为分片2，分片2 在<code>node 3</code>，则客户端节点转发请求至<code>node 3</code>.<br>3、<code>node 3</code>在主分片上执行请求，如果执行成功，则转发该请求至分布分片。当所有的副本节点执行成功返回报告后，<code>node 3</code>报告<code>client_node</code>执行成功。</p></blockquote><p>在<code>client_node</code>上看到执行报告时，文档的修改已经生效。从上面的存储过程可以看出，Es存储的数据是分布在整个集群中的。</p><blockquote><p><strong>检索过程</strong><br>1、<code>client_node</code>向集群中的所有节点发送检索请求。<br>2、每个节点在自己的分片中遍历检索数据，将结果进行排序并返回给<code>client_node</code>。<br>3、<code>client_node</code>将返回的结果进行相关性排序，返回给用户。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式（一）</title>
    <link href="/2019/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="为什么要有工厂模式？"><a href="#为什么要有工厂模式？" class="headerlink" title="为什么要有工厂模式？"></a>为什么要有工厂模式？</h2><blockquote><p>因为在有很多对象需要集中集中操作的时候，可以减少代码的复用和提高代码的灵活性，具体参考下例。</p></blockquote><h2 id="什么是工厂模式？"><a href="#什么是工厂模式？" class="headerlink" title="什么是工厂模式？"></a>什么是工厂模式？</h2><h3 id="1、什么是工厂？"><a href="#1、什么是工厂？" class="headerlink" title="1、什么是工厂？"></a>1、什么是工厂？</h3><pre><code class="hljs typescript">一个专门来创建实例的类叫做工厂，下面是一个简单的例子。<span class="hljs-keyword">public</span> classs Factory&#123;  <span class="hljs-comment">//创建工厂类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">CreateBean</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> arg</span>)</span>&#123;        <span class="hljs-comment">//根据参数创造不同的子类，实现多态。</span>        <span class="hljs-built_in">Object</span> ob = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">switch</span>(arg)&#123;            <span class="hljs-keyword">case</span>: arg1&#123;ob = <span class="hljs-keyword">new</span> Object1();&#125;            <span class="hljs-keyword">case</span>: .....           <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><h2 id="工厂模式的好处有哪些？"><a href="#工厂模式的好处有哪些？" class="headerlink" title="工厂模式的好处有哪些？"></a>工厂模式的好处有哪些？</h2><pre><code class="hljs plain">提高代码服用性和灵活性，工厂模式解决了对象创建问题。</code></pre><p>Tips:</p><blockquote><p>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分。。</p></blockquote><blockquote><p>封装的好处在于将逻辑处理分离开来，到达高复用、高扩展、高灵活性的的目的。</p></blockquote><hr><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>以解决商场收银员业务为背景。</p></blockquote><h2 id="什么是策略模式？"><a href="#什么是策略模式？" class="headerlink" title="什么是策略模式？"></a>什么是策略模式？</h2><blockquote><p>策略模式：它定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式可以让算法的变化不会影响带到适应算法的客户。</p></blockquote><p><img src="Strategy.jpg" alt="策略模式结构图"></p><h2 id="策略模式的使用。"><a href="#策略模式的使用。" class="headerlink" title="策略模式的使用。"></a>策略模式的使用。</h2><pre><code class="hljs plain">在什么时候使用策略模式呢？</code></pre><blockquote><p>策略模式是用来封装算法的，在实践中我们发现可以用它来封装几乎任何类型的规则。只要在不同的时间使用不同的规则，就可以使用策略模式来封装这种变化的可能性。在基本的策略模式中，选择具体的算法实现是由客户端来选择并转给上下文对象来处理的，但是这并没有减少客户端需要判断的压力。简单工厂模式与策略模式的结合可以将选择的任务交给上下文对象。</p></blockquote><p>Tips:</p><blockquote><p>面向对象编程并不是类越多越好，分类的目的是分装，分类的基础是抽象，分类的依据是具有相同的属性和操作。</p></blockquote><blockquote><p>封装变化点是面向对象一种重要的思想。</p></blockquote><hr><h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><h2 id="什么是职责单一模式？"><a href="#什么是职责单一模式？" class="headerlink" title="什么是职责单一模式？"></a>什么是职责单一模式？</h2><blockquote><p>就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><h2 id="什么情景下使用职责单一模式？"><a href="#什么情景下使用职责单一模式？" class="headerlink" title="什么情景下使用职责单一模式？"></a>什么情景下使用职责单一模式？</h2><blockquote><p>如果一个类承担的职责过多，就相当于这些职责耦合在一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。软件设计真正要做的内容是发现职责并且把这些职责进行分离。如果能够想到多于一个的动机去改变这个类，那么这个类就具有多于一个的职责。</p></blockquote><p>Tips：</p><hr><h1 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>对于更改是封闭的，对于扩展是开放的。</p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>当需求发生改变时，需要的考虑的是通过增添代码来实现需求，而不是通过修改。例如在加法系统的基础上要实现减法，可以先将计算进行抽象，然后通过多态实现加法和减法。在此后的变更中就可以通过抽象类来扩展乘法和其他运算了。</p></blockquote><blockquote><p>在软件设计中这种不可以修改，但是可以扩展的思想是一种重要的思想。</p></blockquote><hr><h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><pre><code class="hljs plain">抽象不应该依赖于细节，细节应该依赖于抽象。</code></pre><blockquote><p>简而言之就是针对接口编程，而不是对实现编程。</p></blockquote><h2 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h2><pre><code class="hljs dns"><span class="hljs-keyword">A</span>、高层模块不应该依赖于底层模块。两个都应该依赖抽象。B、抽象不应该依赖于细节，细节应该依赖于抽象。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>native关键字</title>
    <link href="/2019/11/03/native%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/11/03/native%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>初见</strong><br>今天在看Thread start方法源码时其中的start0方法中的出现了native关键字</p></blockquote><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startO</span><span class="hljs-params">()</span></span>;</code></pre><p>native关键字是啥呢？</p><blockquote><p><strong>google</strong><br>当java中的方法用native来修饰的时候，就表示这个方法是一个本地方法。换言之，就是不是使用java语言实现的方法。java在实现多线程时就使用了大量的本地方法，理由很简单java作为跨平台的语言，在与底层系统进行的交互的时候无法通过java语言实现，所以还是需要依靠例如C语言、C++语言来实现与底层的交互。同时这些语言的特性还能极大的提高java程序的运行效率。</p></blockquote><blockquote><p><strong>使用</strong><br>Java平台与主机平台的交互依靠的是JNI（Java Native Interface），即Java本地接口。<br>Java Code———&gt;JNI————&gt;C / C++ Code<br>演示一下调用本地方法的过程：<br>1、创建一个Java类，包含一个native方法和loadLibrary方法</p></blockquote><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstNative</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">static</span>    &#123;        <span class="hljs-comment">//加载类库</span>        System.loadLibrary(<span class="hljs-string">&quot;FirstNative&quot;</span>);    &#125;     <span class="hljs-comment">//native函数</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> native <span class="hljs-built_in">void</span> sayHello();         <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;static-access&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> main(<span class="hljs-built_in">String</span>[] args)    &#123;        <span class="hljs-keyword">new</span> HelloNative().sayHello();    &#125;&#125;</code></pre><p>直接运行之后出现报错信息</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.UnsatisfiedLinkError</span>: <span class="hljs-selector-tag">no</span> <span class="hljs-selector-tag">FirstNative</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.library</span><span class="hljs-selector-class">.path</span>        <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassLoader</span><span class="hljs-selector-class">.loadLibrary</span>(<span class="hljs-selector-tag">ClassLoader</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:1867)</span>        <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Runtime</span><span class="hljs-selector-class">.loadLibrary0</span>(<span class="hljs-selector-tag">Runtime</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:870)</span>        <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.System</span><span class="hljs-selector-class">.loadLibrary</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:1122)</span>        <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">test</span>.&lt;<span class="hljs-selector-tag">clinit</span>&gt;(<span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:6)</span></code></pre><p>表示找不到类,也难怪哦，我们自己写的类名，JVM怎么会知道呢。接下来创建它。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>编译源码 javac FirstNative.java <span class="hljs-regexp">//</span>生成头文件,有个小坑，就是-classpath参数是必须的，而且是绝对路径（到类文件所在的文件夹）。javah -classpath F:\worksp\Javacode FirstNative</code></pre><p>生成的.h文件，其中的头文件jni.h可以在%JAVA_HOME%/include中找到</p><pre><code class="hljs cpp"><span class="hljs-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><span class="hljs-comment">/* Header for class FirstNative */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _Included_FirstNative</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _Included_FirstNative</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Class:     FirstNative</span><span class="hljs-comment"> * Method:    Hello</span><span class="hljs-comment"> * Signature: ()V</span><span class="hljs-comment"> */</span>JNIEXPORT <span class="hljs-keyword">void</span> JNICALL Java_FirstNative_Hello  (JNIEnv *, jclass);<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>根据头文件，来生成本地方法，使用C语言来实现。</p><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;FirstNative.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span> JNIEXPORT void JNICALL Java_FirstNative_Hello&#123;    printf(<span class="hljs-string">&quot;Hello，Native&quot;</span>);    &#125;</code></pre><p>生成DLL动态链接库，用java程序加载库，调用函数即可</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">gcc</span> -m64  -Wl,--add-stdcall-alias -I&quot;[JDK-&gt;</span><span class="hljs-function"><span class="hljs-title">include</span>文件夹绝对路径]&quot; -I&quot;[JDK-&gt;</span><span class="hljs-function"><span class="hljs-title">include</span>-&gt;</span>win32文件夹绝对路径]<span class="hljs-string">&quot; -shared -o [链接库名称] [C源码文件]</span></code></pre><p>执行</p><pre><code class="hljs ebnf"><span class="hljs-attribute">java FirstNative</span></code></pre><p>成功打印</p><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello Native</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java高并发编程-1</title>
    <link href="/2019/11/01/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1/"/>
    <url>/2019/11/01/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>什么是线程？</strong><br>线程是程序执行的一个路径，每一个线程都有自己的局部变量表、程序计数器以及各自的生命周期。</p></blockquote><blockquote><p><strong>线程的生命周期</strong><br>线程的生命周期包括以下5个阶段：<br>**<br>NEW<br>RUNNABLE<br>RUNNING<br>BLOCKED<br>TERMINATED<br>**<br><strong>NEW 状态：</strong><br>在没有执行start之前的状态，表示线程对象被创建，仅此而已。和创建一个其他对象没有区别。<br><strong>RUNNABLE状态：</strong><br>调用start方法后，JVM进程创建一个线程，但是仅仅是创建一个线程，并不代表线程被执行，此时的线程在等待CPU的调度。<br><strong>RUNNING状态：</strong><br>此时的线程开始真正的执行逻辑代码，有一个知识点是一个处于RUNNING状态的线程事实上也是一个RUNNABLE状态的线程，反过来不成立。(我的理解是，正在执行的线程可以是在单核情况下运行的，这就可以说是线程在RUNNABLE和RUNNING之间切换，所以可以说是处于RUNNABLE。但是一个处于RUNNABLE的线程本身就就没有被运行，就不可以说是处于RUNNING状态。)RUNNING状态下的线程可以说是一个想成的必经状态，除非线程意外终止。否则无论是进入BLOCKED状态还是进入TERMINATED状态，都需要经过RUNNING状态。<br><strong>BLOCKED状态：</strong><br>从RUNNING状态进入BLOCKED状态的几种情况：<br>1、调用了sleep或者wait方法，进入了waitSet中；<br>2、进行了阻塞的IO操作；<br>3、获取某个锁资源，从而加入了该锁的阻塞队列；<br><strong>TERMINATED状态：</strong><br>TERMINATED状态是线程的最终状态，该状态下不会切换到其他任何状态，因为此章台代表线程的生命周期已经结束。</p></blockquote><blockquote><p><strong>线程的start方法——模板模式在Thread中的应用</strong><br>start方法的源码：</p></blockquote><pre><code class="hljs csharp"><span class="hljs-function">publi c  synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;     <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>) <span class="hljs-meta">#检查线程状态</span>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();      <span class="hljs-keyword">group</span>.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">this</span>);      boolean started = <span class="hljs-literal">false</span>;      <span class="hljs-keyword">try</span> &#123;          startO();          started = <span class="hljs-literal">true</span>;           &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (!started) &#123;                        <span class="hljs-keyword">group</span>.threadStartFailed(<span class="hljs-keyword">this</span>);                         &#125;                         catch (Throwable ignore) &#123;                        &#125;              &#125;          &#125;</code></pre><blockquote><p>核心函数start0是一个本地方法：</p></blockquote><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;</code></pre><blockquote><p>从上面的代码可以看出，一个线程是不可以start两次的，不然会报非法线程异常。同时一个生命周期结束的线程在调用start方法是也会报出相同的异常。同时还可以知道线程的真正逻辑在run方法中，这里的run函数就相当于模板模式中需要重写的函数，而start函数就是模板模式中的模板函数。这样做的好处是将线程的控制和业务的执行分离开来。</p></blockquote><blockquote><p><strong>Runnable和Thread的关系及使用</strong><br>网上看了好多资料，最后还是没有找到一个比较有说服力的答案，最后没有办法。我打开了Thread的源码一探究竟。</p></blockquote><pre><code class="hljs stata"><span class="hljs-comment">//开头是一些版权信息，接下来是一大段介绍摘抄几句比较重要的：</span> Each thread<span class="hljs-comment"> * may or may not also be marked as a daemon. When code running in</span><span class="hljs-comment"> * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span><span class="hljs-comment"> * thread has its priority initially set equal to the priority of the</span><span class="hljs-comment"> * creating thread, and is a daemon thread if and only if the</span><span class="hljs-comment"> * creating thread is a daemon.</span> （貌似说的是线程被创建的时候会被设置默认优先级，默认的优先级是和创建线程的优先级是一样的）<span class="hljs-comment"> * When a Java Virtual Machine starts up, there is usually a single</span><span class="hljs-comment"> * non-daemon thread (which typically calls the method named</span><span class="hljs-comment"> * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span><span class="hljs-comment"> * Machine continues to execute threads until either of the following</span><span class="hljs-comment"> * occurs:</span><span class="hljs-comment"> * &lt;ul&gt;</span><span class="hljs-comment"> * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span><span class="hljs-comment"> *     called and the security manager has permitted the exit operation</span><span class="hljs-comment"> *     to take place.</span><span class="hljs-comment"> * &lt;li&gt;All threads that are not daemon threads have died, either by</span><span class="hljs-comment"> *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span><span class="hljs-comment"> *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span><span class="hljs-comment"> *     method.</span><span class="hljs-comment"> * &lt;/ul&gt;</span> （JVM启动时只有一个非守护线程，这些线程一直被JVM执行直到一下几种情况：<span class="hljs-comment">    *安全退出</span><span class="hljs-comment">    *非守护线程全部死亡</span><span class="hljs-comment">    *引起异常）</span><span class="hljs-comment">* There are two ways to create a new thread of execution. One is to</span><span class="hljs-comment"> * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span><span class="hljs-comment"> * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span><span class="hljs-comment"> * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span><span class="hljs-comment"> * allocated and started. For example, a thread that computes primes</span><span class="hljs-comment"> * larger than a stated value could be written as follows:</span><span class="hljs-comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span><span class="hljs-comment"> *     class PrimeThread extends Thread &#123;</span><span class="hljs-comment"> *         long minPrime;</span><span class="hljs-comment"> *         PrimeThread(long minPrime) &#123;</span><span class="hljs-comment"> *             this.minPrime = minPrime;</span><span class="hljs-comment"> *         &#125;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *         public void run() &#123;</span><span class="hljs-comment"> *             // compute primes larger than minPrime</span><span class="hljs-comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span><span class="hljs-comment"> *         &#125;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * The following code would then create a thread and start it running:</span><span class="hljs-comment"> * &lt;blockquote&gt;&lt;pre&gt;</span><span class="hljs-comment"> *     PrimeThread p = new PrimeThread(143);</span><span class="hljs-comment"> *     p.start();</span><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><span class="hljs-comment"> * &lt;p&gt;</span> （有两种方法可以创建一个线程，一是继承Thread类，重写<span class="hljs-keyword">run</span>方法并给出了实例函数）<span class="hljs-comment"> * The other way to create a thread is to declare a class that</span><span class="hljs-comment"> * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span><span class="hljs-comment"> * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span><span class="hljs-comment"> * then be allocated, passed as an argument when creating</span><span class="hljs-comment"> * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span><span class="hljs-comment"> * style looks like the following:</span><span class="hljs-comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span><span class="hljs-comment"> *     class PrimeRun implements Runnable &#123;</span><span class="hljs-comment"> *         long minPrime;</span><span class="hljs-comment"> *         PrimeRun(long minPrime) &#123;</span><span class="hljs-comment"> *             this.minPrime = minPrime;</span><span class="hljs-comment"> *         &#125;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *         public void run() &#123;</span><span class="hljs-comment"> *             // compute primes larger than minPrime</span><span class="hljs-comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span><span class="hljs-comment"> *         &#125;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * The following code would then create a thread and start it running:</span><span class="hljs-comment"> * &lt;blockquote&gt;&lt;pre&gt;</span><span class="hljs-comment"> *     PrimeRun p = new PrimeRun(143);</span><span class="hljs-comment"> *     new Thread(p).start();</span><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * Every thread has a name for identification purposes. More than</span><span class="hljs-comment"> * one thread may have the same name. If a name is not specified when</span><span class="hljs-comment"> * a thread is created, a new name is generated for it.</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * Unless otherwise noted, passing a &#123;@code null&#125; argument to a constructor</span><span class="hljs-comment"> * or method in this class will cause a &#123;@link NullPointerException&#125; to be</span><span class="hljs-comment"> * thrown.</span> （另外一方法是实现Runnable接口，并给出了实现方法，需要注意的是两种方法的启动线程的方式是不一样的。）</code></pre><p>其实从上面的介绍就可以看出来，Thread和Runnable是没有本质区别的，只不过按照OOP来说一个是具体的实现，一个是接口的规范。只是两种实现线程的不同操作。<br>接下来是几个比较重要的函数：</p><pre><code class="hljs aspectj"><span class="hljs-comment">//用来生成线程ID的整型变量，为了保证唯一性添加synchronized同步锁。</span> <span class="hljs-comment">/* For autonumbering anonymous threads. */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextThreadNum</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> threadInitNumber++;    &#125;<span class="hljs-comment">//可以看到前面说到的start两次线程失败是因为有这个参数，同时volatile参数是来保持其可见性，当其被改变时调用此线程的对象可以立即感知到。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> threadStatus = <span class="hljs-number">0</span>;<span class="hljs-comment">//属性中有target，解释为将要被run的对象。</span><span class="hljs-comment">/* What will be run. */</span>    <span class="hljs-keyword">private</span> Runnable <span class="hljs-keyword">target</span>;<span class="hljs-comment">//Thread的构造函数太多了，不一一罗列。其中有Runnable target的上面的target属性就会被赋值，结合下面的run方法就可以知道Thread执行的也是Runnable的方法。</span><span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">target</span>.run();        &#125;    &#125;</code></pre><p>一圈看下来，发现Thread是一个完整的类，提供了丰富的接口函数实现，通过继承Thread实现的线程对象可以有丰富的功能。利用Runnable实现的线程最终还是要放进Thread中去启动，只不过可以设计自己的业务逻辑而不必继承Thread的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
